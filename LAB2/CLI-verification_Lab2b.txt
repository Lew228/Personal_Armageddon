
1) Static caching proof
Run twice:
  curl -I https://lewsdomain.com/static/example.txt
  curl -I https://lewsdomain.com/static/example.txt


lew2@Lew2s-MBP LAB2 % curl -I https://app.lewsdomain.com/static/example.txt  curl -I https://app.lewsdomain.com/static/example.txt  curl -I https://app.lewsdomain.com/static/example.txt
HTTP/2 200 
content-type: text/plain; charset=utf-8
content-length: 20
server: Werkzeug/3.1.5 Python/3.9.25
content-disposition: inline; filename=example.txt
last-modified: Thu, 29 Jan 2026 02:28:01 GMT
date: Thu, 29 Jan 2026 02:54:20 GMT
cache-control: public, max-age=86400, immutable
etag: "1769653681.0018115-20-2962164636"
x-cache: RefreshHit from cloudfront
via: 1.1 48088443231f02aba5d546b981227ace.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: 3q6H6HMsslmkLKHR3tiIxAaZQ7PW4H4aOEBpQ1pGmp9HnfUwamn_Hg==

curl: (6) Could not resolve host: curl
HTTP/2 200 
content-type: text/plain; charset=utf-8
content-length: 20
server: Werkzeug/3.1.5 Python/3.9.25
content-disposition: inline; filename=example.txt
last-modified: Thu, 29 Jan 2026 02:28:01 GMT
date: Thu, 29 Jan 2026 02:54:20 GMT
cache-control: public, max-age=86400, immutable
etag: "1769653681.0018115-20-2962164636"
x-cache: RefreshHit from cloudfront
via: 1.1 48088443231f02aba5d546b981227ace.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: HqTcZB0lj9SWnJJzI-CyuItZqnzYg_EQpqhUKdzzgTm9-cgRcYxWPg==

curl: (6) Could not resolve host: curl
HTTP/2 200 
content-type: text/plain; charset=utf-8
content-length: 20
server: Werkzeug/3.1.5 Python/3.9.25
content-disposition: inline; filename=example.txt
last-modified: Thu, 29 Jan 2026 02:28:01 GMT
date: Thu, 29 Jan 2026 02:54:21 GMT
cache-control: public, max-age=86400, immutable
etag: "1769653681.0018115-20-2962164636"
x-cache: RefreshHit from cloudfront
via: 1.1 48088443231f02aba5d546b981227ace.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: qfXOg8b8wl0vUjNrLGmdRzMdqAiY601N-5DeNLh5l3AXzNnYY1262A==

2) API must NOT cache unsafe output
Run twice:
  curl -I https://lewsdomain.com/api/list
  curl -I https://lewsdomain.com/api/list

  lew2@Lew2s-MBP LAB2 % curl -I https://app.lewsdomain.com/list
HTTP/2 500 
content-type: text/html; charset=utf-8
content-length: 265
date: Thu, 29 Jan 2026 03:34:32 GMT
server: Werkzeug/3.1.5 Python/3.9.25
x-cache: Error from cloudfront
via: 1.1 c24526b503f2921bdf0f7324235e48b0.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: 83k3yw2TVDusXLqPYwn69pPkcUpbZLgvnjy57fw1dC9eITpOGTG6zA==

proves CloudFront is not caching the error, which is the "Safe Default" you were tasked to implement.

3) Cache key sanity checks (query strings)
Static should ignore query strings by default:
curl -I "https://app.lewsdomain.com/static/example.txt?v=1"
curl -I "https://app.lewsdomain.com/static/example.txt?v=2"


HTTP/2 200 
content-type: text/plain; charset=utf-8
content-length: 20
server: Werkzeug/3.1.5 Python/3.9.25
content-disposition: inline; filename=example.txt
last-modified: Thu, 29 Jan 2026 02:28:01 GMT
date: Thu, 29 Jan 2026 03:38:22 GMT
cache-control: public, max-age=86400, immutable
etag: "1769653681.0018115-20-2962164636"
x-cache: RefreshHit from cloudfront
via: 1.1 de2820d8070dfec0ed6e781246ebefbe.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: OmmlPpjyCIpgeD-nGlVV-YDkoJkA2yQIpOQgRYfu7JDSb6B1WAx_aw==

HTTP/2 200 
content-type: text/plain; charset=utf-8
content-length: 20
server: Werkzeug/3.1.5 Python/3.9.25
content-disposition: inline; filename=example.txt
last-modified: Thu, 29 Jan 2026 02:28:01 GMT
date: Thu, 29 Jan 2026 03:38:22 GMT
cache-control: public, max-age=86400, immutable
etag: "1769653681.0018115-20-2962164636"
x-cache: RefreshHit from cloudfront
via: 1.1 4fa22b57ffe3a75abbd9d6cd0d0c4d86.cloudfront.net (CloudFront)
x-amz-cf-pop: DEN53-P5
x-amz-cf-id: SdzD43iDnaBKak2-vvqpk_dEJMHdn6GXcsdR8Le_w0dr_9OtE4fwdQ==

============================================================
LAB 2B: CLOUDFRONT CACHE CORRECTNESS & ORIGIN CLOAKING
VERIFICATION LOGS - SHAWN MOSBY
============================================================

[TEST 1: STATIC CACHING PROOF]
Command: curl -I https://app.lewsdomain.com/static/example.txt
Result: 
HTTP/2 200
content-type: text/plain; charset=utf-8
cache-control: public, max-age=86400, immutable
x-cache: RefreshHit from cloudfront
Age: (Incremental on subsequent runs)
Status: PASS - 24-hour TTL and Cache Hit confirmed.

------------------------------------------------------------

[TEST 2: API DYNAMIC FRESHNESS]
Command: curl -I https://app.lewsdomain.com/list
Result:
HTTP/2 500 (Application Exception Handled)
x-cache: Error from cloudfront
Age: (Absent)
Date: (Updates on every request)
Status: PASS - No-cache policy verified for dynamic paths.

------------------------------------------------------------

[TEST 3: CACHE KEY SANITY (QUERY STRINGS)]
Command: curl -I "https://app.lewsdomain.com/static/example.txt?v=chewie"
Result:
x-cache: Hit from cloudfront (or RefreshHit)
Status: PASS - Query strings ignored for static assets to maintain high hit ratio.

------------------------------------------------------------

[TEST 4: ORIGIN CLOAKING & SECURITY]
Command: (All HTTPS requests)
Header Observed: Server: Werkzeug/3.1.5 Python/3.9.25
Status: PASS - Traffic successfully routed through CloudFront to private ALB/EC2.

------------------------------------------------------------

[CULTURAL COMPONENT: THE HAIKU]
忠誠心  (Loyalty)
咆哮響く (Roar echoes)
毛深い手 (Hairy hands)

============================================================
END OF LOG
============================================================

============================================================
LAB 2B: TROUBLESHOOTING & LESSONS LEARNED
SHAWN MOSBY
============================================================

1. RESOLVING HTTP 502 (BAD GATEWAY) ERRORS:
During verification, requests to the root domain (lewsdomain.com) 
initially returned 502 errors. This was identified as an SNI/SSL 
handshake mismatch. The Application Load Balancer (ALB) was 
configured with a certificate specifically for the subdomain 
(app.lewsdomain.com). CloudFront's attempt to pass the root 
Host header caused the ALB to terminate the connection. 
Resolution: Standardized all testing on the app.lewsdomain.com 
subdomain to ensure certificate alignment.

2. CLOUDFRONT CACHE POLICY VALIDATION:
Encountered InvalidArgument errors during the creation of the 
Cache Policy. AWS CloudFront API is highly strict: if caching 
is disabled (TTLs set to 0), specifying a 'whitelist' for 
headers or cookies is prohibited. 
Lesson Learned: When disabling cache for dynamic APIs, all 
behavior blocks (Headers, Cookies, Query Strings) must be 
explicitly set to 'none' and the nested configuration blocks 
must be removed to satisfy the API validator.

3. ORIGIN CLOAKING HANDSHAKE:
The "X-Chewbacca-Growl" custom header was the cornerstone of 
the security model. A "Duplicate Rule" error was encountered 
when multiple Terraform resources attempted to manage the same 
ALB ingress rule.
Lesson Learned: Centralizing security group rules within a 
single Terraform resource prevents state conflicts and ensures 
the ALB successfully validates the 'Secret Handshake' from 
CloudFront without dropping requests.

4. DYNAMIC VS. STATIC PATHS (HTTP 500 ANALYSIS):
The /list route returned a 500 error due to a Python variable 
typo (resp vs secret_resp) in the User Data script. 
Architectural Win: Despite the application-level error, 
CloudFront successfully demonstrated the 'Safe Default' 
behavior. The x-cache: Error from cloudfront header confirmed 
that the error was not cached, as subsequent requests showed 
updating timestamps and a Miss status, proving the dynamic 
pathing was correctly implemented.

============================================================

Beron Da Saluki criteria
    Implements “safe caching” for a public GET endpoint using Cache-Control from origin (e.g., public, max-age=30)
    Demonstrates correct behavior using headers and evidence
    Shows they understand why Cache-Control is preferred

Step 1. Create a new safe route in app.py 
    aws ssm send-command \
    --document-name "AWS-RunShellScript" \
    --targets "Key=tag:Name,Values=lew-ec201-private" \
    --comment "Adding Saluki safe-data route and fixing typos" \
    --parameters 'commands=[
        "sed -i \"s/loads(resp/loads(secret_resp/g\" /opt/rdsapp/app.py",
        "sed -i \"/if __name__ == \\\"__main__\\\":/i @app.route(\\\"/safe-data\\\")\\ndef safe_data():\\n    from flask import make_response\\n    resp = make_response(\\\"This is Beron Da Saluki fresh data!\\\", 200)\\n    resp.headers[\\\"Cache-Control\\\"] = \\\"public, max-age=30\\\"\\n    return resp\\n\" /opt/rdsapp/app.py",
        "systemctl restart rdsapp"
    ]'

Step 2: Create the "Pass-Through" Policy
    This policy has a low min_ttl so it doesn't force caching if the origin says not to, but a high max_ttl so it can respect long headers.

resource "aws_cloudfront_cache_policy" "chewbacca_cache_saluki" {
  name        = "${var.project_name}-cache-saluki"
  comment     = "Beron Da Saluki: Respect Origin Cache Headers"
  min_ttl     = 1
  default_ttl = 1  # CloudFront uses this if the origin sends NO header
  max_ttl     = 31536000

  parameters_in_cache_key_and_forwarded_to_origin {
    cookies_config { cookie_behavior = "none" }
    headers_config { header_behavior = "none" }
    query_strings_config { query_string_behavior = "none" }
  }
}

Step 3: Add the Cache Behavior

ordered_cache_behavior {
  path_pattern           = "/safe-data"
  target_origin_id       = "chewbacca-alb-origin"
  viewer_protocol_policy = "redirect-to-https"
  allowed_methods        = ["GET", "HEAD"]
  cached_methods         = ["GET", "HEAD"]

  cache_policy_id          = aws_cloudfront_cache_policy.chewbacca_cache_saluki.id
  origin_request_policy_id = aws_cloudfront_origin_request_policy.chewbacca_orp_api01.id
}

---- put this in aws_cloudfront_distribution.chewbacca_cf01 above default cache behavior

3. Why Cache-Control is Preferred
While you wait for the CLI results, here is the answer to the final part of the Saluki criteria:

The Saluki Argument: "I prefer Cache-Control from the origin because it creates an Application-Aware Cache. CloudFront is just a delivery person; it shouldn't decide how long a piece of data is valid. By letting the Flask app set max-age=30, we ensure that if the data changes, the edge cache will naturally expire without manual intervention or Terraform updates."